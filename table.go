package bartlett

import (
	sqrl "github.com/Masterminds/squirrel"
	"github.com/buger/jsonparser"
)

// A Table represents a table in the database.
// Name is required.
// Writable determines whether the table allows INSERT, UPDATE, and DELETE queries. Default is read-only.
// UserID is the name of column containing user IDs. It should match the output of the UserIDProvider passed to Bartlett.
// If UserID is left blank, all rows will be available regardless of the UserIDProvider.
type Table struct {
	columns  []string
	Name     string
	IDColumn IDSpec
	Writable bool
	UserID   string
}

// An IDSpec is used for primary keys that are generated by the application rather than the database.
// If you need a random ID, for example, this is where you would generate it.
// This column is protected from tampering by API users in INSERT and UPDATE operations.
type IDSpec struct {
	Name      string
	Generator func() interface{}
}

func (t Table) prepareInsert(inputBody []byte, userID, rowID interface{}) sqrl.InsertBuilder {
	query := sqrl.Insert(t.Name)
	validCols := t.validWriteColumns()
	var vals []interface{}
	_ = jsonparser.ObjectEach(inputBody, func(key []byte, val []byte, dataType jsonparser.ValueType, offset int) error {
		if sliceContains(validCols, string(key)) {
			query = query.Columns(string(key))
			vals = append(vals, string(val))
		}
		return nil
	})

	if rowID != nil {
		query = query.Columns(t.IDColumn.Name)
		vals = append(vals, rowID)
	}
	if len(t.UserID) > 0 {
		query = query.Columns(t.UserID)
		vals = append(vals, userID)
	}

	return query.Values(vals...)
}

func (t Table) prepareUpdate(inputBody []byte, userID interface{}, query sqrl.UpdateBuilder) sqrl.UpdateBuilder {
	validCols := t.validWriteColumns()
	_ = jsonparser.ObjectEach(inputBody, func(key []byte, val []byte, dataType jsonparser.ValueType, offset int) error {
		if sliceContains(validCols, string(key)) {
			query = query.Set(string(key), val)
		}
		return nil
	})

	return query
}

// validReadColumns strips out columns that are not part of the table schema.
func (t Table) validReadColumns(cols []string) []string {
	var out []string
	for _, col := range cols { // Iterate the potentially pathological input only once.
		if sliceContains(t.columns, col) || col == `or` || col == `and` {
			out = append(out, col)
		}
	}

	return out
}

// validWriteColumns returns a slice of columns that are not UserID or IDColumn.
func (t Table) validWriteColumns() []string {
	out := t.columns
	for i, name := range out {
		if name == t.UserID ||
			name == t.IDColumn.Name {
			out[i] = out[len(out)-1]
			out = out[:len(out)-1]
		}
	}

	return out
}
